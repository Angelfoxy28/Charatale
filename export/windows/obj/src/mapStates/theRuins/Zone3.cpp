// Generated by Haxe 4.3.3
#include <hxcpp.h>

#ifndef INCLUDED_Paths
#include <Paths.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxAtlasFrames
#include <flixel/graphics/frames/FlxAtlasFrames.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxTween
#include <flixel/tweens/FlxTween.h>
#endif
#ifndef INCLUDED_flixel_tweens_misc_VarTween
#include <flixel/tweens/misc/VarTween.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_mapStates_theRuins_Zone3
#include <mapStates/theRuins/Zone3.h>
#endif
#ifndef INCLUDED_player_CameraFuncs
#include <player/CameraFuncs.h>
#endif
#ifndef INCLUDED_player_Movement
#include <player/Movement.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_f48efaaa003b7ac9_12_new,"mapStates.theRuins.Zone3","new",0xad7eb3b5,"mapStates.theRuins.Zone3.new","mapStates/theRuins/Zone3.hx",12,0x67d5513b)
HX_LOCAL_STACK_FRAME(_hx_pos_f48efaaa003b7ac9_24_create,"mapStates.theRuins.Zone3","create",0x28c386c7,"mapStates.theRuins.Zone3.create","mapStates/theRuins/Zone3.hx",24,0x67d5513b)
HX_LOCAL_STACK_FRAME(_hx_pos_f48efaaa003b7ac9_81_update,"mapStates.theRuins.Zone3","update",0x33b9a5d4,"mapStates.theRuins.Zone3.update","mapStates/theRuins/Zone3.hx",81,0x67d5513b)
HX_LOCAL_STACK_FRAME(_hx_pos_f48efaaa003b7ac9_105_asMove1,"mapStates.theRuins.Zone3","asMove1",0xcd276b83,"mapStates.theRuins.Zone3.asMove1","mapStates/theRuins/Zone3.hx",105,0x67d5513b)
HX_LOCAL_STACK_FRAME(_hx_pos_f48efaaa003b7ac9_110_asMove2,"mapStates.theRuins.Zone3","asMove2",0xcd276b84,"mapStates.theRuins.Zone3.asMove2","mapStates/theRuins/Zone3.hx",110,0x67d5513b)
HX_LOCAL_STACK_FRAME(_hx_pos_f48efaaa003b7ac9_113_asMove3,"mapStates.theRuins.Zone3","asMove3",0xcd276b85,"mapStates.theRuins.Zone3.asMove3","mapStates/theRuins/Zone3.hx",113,0x67d5513b)
HX_LOCAL_STACK_FRAME(_hx_pos_f48efaaa003b7ac9_118_asMove4,"mapStates.theRuins.Zone3","asMove4",0xcd276b86,"mapStates.theRuins.Zone3.asMove4","mapStates/theRuins/Zone3.hx",118,0x67d5513b)
namespace mapStates{
namespace theRuins{

void Zone3_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_f48efaaa003b7ac9_12_new)
HXLINE(  21)		this->canMove = true;
HXLINE(  12)		super::__construct();
            	}

Dynamic Zone3_obj::__CreateEmpty() { return new Zone3_obj; }

void *Zone3_obj::_hx_vtable = 0;

Dynamic Zone3_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Zone3_obj > _hx_result = new Zone3_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Zone3_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x6db6d34f) {
		if (inClassId<=(int)0x62817b24) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x62817b24;
		} else {
			return inClassId==(int)0x6db6d34f;
		}
	} else {
		return inClassId==(int)0x7c795c9f || inClassId==(int)0x7ccf8994;
	}
}

void Zone3_obj::create(){
            	HX_GC_STACKFRAME(&_hx_pos_f48efaaa003b7ac9_24_create)
HXLINE(  26)		 ::flixel::FlxSprite _hx_tmp =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,0,0,null());
HXDLIN(  26)		this->zone = _hx_tmp->loadGraphic(::Paths_obj::mapImg(HX_("zone 3",3f,a1,06,fa),HX_("the ruins",1c,7c,99,f6)),null(),null(),null(),null(),null());
HXLINE(  27)		this->zone->scale->set_x(( (Float)(2) ));
HXLINE(  28)		this->zone->scale->set_y(( (Float)(2) ));
HXLINE(  29)		this->zone->updateHitbox();
HXLINE(  30)		{
HXLINE(  30)			 ::flixel::FlxSprite _this = this->zone;
HXDLIN(  30)			int axes = 17;
HXDLIN(  30)			bool _hx_tmp1;
HXDLIN(  30)			if ((axes != 1)) {
HXLINE(  30)				_hx_tmp1 = (axes == 17);
            			}
            			else {
HXLINE(  30)				_hx_tmp1 = true;
            			}
HXDLIN(  30)			if (_hx_tmp1) {
HXLINE(  30)				int _hx_tmp2 = ::flixel::FlxG_obj::width;
HXDLIN(  30)				_this->set_x(((( (Float)(_hx_tmp2) ) - _this->get_width()) / ( (Float)(2) )));
            			}
HXDLIN(  30)			bool _hx_tmp3;
HXDLIN(  30)			if ((axes != 16)) {
HXLINE(  30)				_hx_tmp3 = (axes == 17);
            			}
            			else {
HXLINE(  30)				_hx_tmp3 = true;
            			}
HXDLIN(  30)			if (_hx_tmp3) {
HXLINE(  30)				int _hx_tmp4 = ::flixel::FlxG_obj::height;
HXDLIN(  30)				_this->set_y(((( (Float)(_hx_tmp4) ) - _this->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE(  31)		this->add(this->zone);
HXLINE(  33)		this->check =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,0,100,null());
HXLINE(  34)		 ::flixel::FlxSprite _hx_tmp5 = this->check;
HXDLIN(  34)		_hx_tmp5->set_frames(::Paths_obj::getSparrowAtlas(HX_("checkpoint",88,46,52,43)));
HXLINE(  35)		this->check->animation->addByPrefix(HX_("aea",fd,f2,49,00),HX_("point",50,b4,8f,c6),5,true,null(),null());
HXLINE(  36)		this->check->animation->play(HX_("aea",fd,f2,49,00),null(),null(),null());
HXLINE(  37)		this->check->scale->set_x(( (Float)(2) ));
HXLINE(  38)		this->check->scale->set_y(( (Float)(2) ));
HXLINE(  39)		this->check->updateHitbox();
HXLINE(  40)		{
HXLINE(  40)			 ::flixel::FlxSprite _this1 = this->check;
HXDLIN(  40)			int axes1 = 1;
HXDLIN(  40)			bool _hx_tmp6;
HXDLIN(  40)			if ((axes1 != 1)) {
HXLINE(  40)				_hx_tmp6 = (axes1 == 17);
            			}
            			else {
HXLINE(  40)				_hx_tmp6 = true;
            			}
HXDLIN(  40)			if (_hx_tmp6) {
HXLINE(  40)				int _hx_tmp7 = ::flixel::FlxG_obj::width;
HXDLIN(  40)				_this1->set_x(((( (Float)(_hx_tmp7) ) - _this1->get_width()) / ( (Float)(2) )));
            			}
HXDLIN(  40)			bool _hx_tmp8;
HXDLIN(  40)			if ((axes1 != 16)) {
HXLINE(  40)				_hx_tmp8 = (axes1 == 17);
            			}
            			else {
HXLINE(  40)				_hx_tmp8 = true;
            			}
HXDLIN(  40)			if (_hx_tmp8) {
HXLINE(  40)				int _hx_tmp9 = ::flixel::FlxG_obj::height;
HXDLIN(  40)				_this1->set_y(((( (Float)(_hx_tmp9) ) - _this1->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE(  41)		this->add(this->check);
HXLINE(  43)		this->asriel =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,0,0,null());
HXLINE(  44)		 ::flixel::FlxSprite _hx_tmp10 = this->asriel;
HXDLIN(  44)		_hx_tmp10->set_frames(::Paths_obj::getSparrowAtlas(HX_("asriel",d0,0d,5d,4b)));
HXLINE(  45)		this->asriel->animation->addByPrefix(HX_("Down",82,24,47,2d),HX_("Down",82,24,47,2d),0,true,null(),null());
HXLINE(  46)		this->asriel->animation->addByPrefix(HX_("Up",7b,4a,00,00),HX_("Up",7b,4a,00,00),5,true,null(),null());
HXLINE(  47)		this->asriel->animation->addByPrefix(HX_("Left",27,34,89,32),HX_("Left",27,34,89,32),5,true,null(),null());
HXLINE(  48)		this->asriel->scale->set_x(( (Float)(2) ));
HXLINE(  49)		this->asriel->scale->set_y(( (Float)(2) ));
HXLINE(  50)		this->asriel->updateHitbox();
HXLINE(  51)		{
HXLINE(  51)			 ::flixel::FlxSprite _this2 = this->asriel;
HXDLIN(  51)			int axes2 = 17;
HXDLIN(  51)			bool _hx_tmp11;
HXDLIN(  51)			if ((axes2 != 1)) {
HXLINE(  51)				_hx_tmp11 = (axes2 == 17);
            			}
            			else {
HXLINE(  51)				_hx_tmp11 = true;
            			}
HXDLIN(  51)			if (_hx_tmp11) {
HXLINE(  51)				int _hx_tmp12 = ::flixel::FlxG_obj::width;
HXDLIN(  51)				_this2->set_x(((( (Float)(_hx_tmp12) ) - _this2->get_width()) / ( (Float)(2) )));
            			}
HXDLIN(  51)			bool _hx_tmp13;
HXDLIN(  51)			if ((axes2 != 16)) {
HXLINE(  51)				_hx_tmp13 = (axes2 == 17);
            			}
            			else {
HXLINE(  51)				_hx_tmp13 = true;
            			}
HXDLIN(  51)			if (_hx_tmp13) {
HXLINE(  51)				int _hx_tmp14 = ::flixel::FlxG_obj::height;
HXDLIN(  51)				_this2->set_y(((( (Float)(_hx_tmp14) ) - _this2->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE(  52)		this->add(this->asriel);
HXLINE(  54)		this->chara =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,(( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) )),(( (Float)(::flixel::FlxG_obj::height) ) / ( (Float)(2) )),null());
HXLINE(  55)		 ::flixel::FlxSprite _hx_tmp15 = this->chara;
HXDLIN(  55)		_hx_tmp15->set_frames(::Paths_obj::getSparrowAtlas(HX_("Chara",ab,0c,e1,d8)));
HXLINE(  56)		this->chara->animation->addByPrefix(HX_("Up",7b,4a,00,00),HX_("Up",7b,4a,00,00),4,null(),null(),null());
HXLINE(  57)		this->chara->animation->addByPrefix(HX_("Down",82,24,47,2d),HX_("Down",82,24,47,2d),4,null(),null(),null());
HXLINE(  58)		this->chara->animation->addByPrefix(HX_("DownRight",fa,bf,4c,a1),HX_("Down",82,24,47,2d),4,null(),null(),null());
HXLINE(  59)		this->chara->animation->addByPrefix(HX_("DownLeft",a9,c1,49,56),HX_("Down",82,24,47,2d),4,null(),null(),null());
HXLINE(  60)		this->chara->animation->addByPrefix(HX_("Left",27,34,89,32),HX_("Left",27,34,89,32),4,null(),null(),null());
HXLINE(  61)		this->chara->animation->addByPrefix(HX_("UpRight",61,53,2a,13),HX_("Up",7b,4a,00,00),4,null(),null(),null());
HXLINE(  62)		this->chara->animation->addByPrefix(HX_("UpLeft",22,d8,bf,ab),HX_("Up",7b,4a,00,00),4,null(),null(),null());
HXLINE(  63)		this->chara->animation->addByPrefix(HX_("Right",bc,7b,91,7c),HX_("Right",bc,7b,91,7c),4,null(),null(),null());
HXLINE(  64)		this->chara->scale->set_x(( (Float)(2) ));
HXLINE(  65)		this->chara->scale->set_y(( (Float)(2) ));
HXLINE(  66)		this->chara->updateHitbox();
HXLINE(  67)		 ::flixel::FlxSprite fh = this->chara;
HXDLIN(  67)		fh->set_x((fh->x - ( (Float)(40) )));
HXLINE(  68)		this->add(this->chara);
HXLINE(  70)		this->charaCol =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,306,((Float)635.5),null());
HXLINE(  71)		this->charaCol->makeGraphic(40,25,-16711936,null(),null());
HXLINE(  72)		this->charaCol->set_visible(false);
HXLINE(  73)		{
HXLINE(  73)			 ::flixel::FlxSprite _this3 = this->charaCol;
HXDLIN(  73)			int axes3 = 1;
HXDLIN(  73)			bool _hx_tmp16;
HXDLIN(  73)			if ((axes3 != 1)) {
HXLINE(  73)				_hx_tmp16 = (axes3 == 17);
            			}
            			else {
HXLINE(  73)				_hx_tmp16 = true;
            			}
HXDLIN(  73)			if (_hx_tmp16) {
HXLINE(  73)				int _hx_tmp17 = ::flixel::FlxG_obj::width;
HXDLIN(  73)				_this3->set_x(((( (Float)(_hx_tmp17) ) - _this3->get_width()) / ( (Float)(2) )));
            			}
HXDLIN(  73)			bool _hx_tmp18;
HXDLIN(  73)			if ((axes3 != 16)) {
HXLINE(  73)				_hx_tmp18 = (axes3 == 17);
            			}
            			else {
HXLINE(  73)				_hx_tmp18 = true;
            			}
HXDLIN(  73)			if (_hx_tmp18) {
HXLINE(  73)				int _hx_tmp19 = ::flixel::FlxG_obj::height;
HXDLIN(  73)				_this3->set_y(((( (Float)(_hx_tmp19) ) - _this3->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE(  74)		this->add(this->charaCol);
HXLINE(  76)		 ::flixel::FlxSprite _hx_tmp20 = this->chara;
HXDLIN(  76)		Float _hx_tmp21 = this->zone->y;
HXDLIN(  76)		Float _hx_tmp22 = this->zone->x;
HXDLIN(  76)		Float _hx_tmp23 = (_hx_tmp22 + this->zone->get_width());
HXDLIN(  76)		Float _hx_tmp24 = this->zone->y;
HXDLIN(  76)		::player::CameraFuncs_obj::newFollow(_hx_tmp20,( (Float)(0) ),_hx_tmp21,_hx_tmp23,(_hx_tmp24 + (this->zone->get_height() * ((Float)1.23))));
HXLINE(  78)		this->super::create();
            	}


void Zone3_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_f48efaaa003b7ac9_81_update)
HXLINE(  83)		if (this->canMove) {
HXLINE(  85)			::player::Movement_obj::keyboardMove(this->charaCol,null(),null());
HXLINE(  86)			::player::Movement_obj::keyboardMove(this->chara,true,null());
            		}
HXLINE(  89)		this->chara->set_x(this->charaCol->x);
HXLINE(  90)		this->chara->set_y((this->charaCol->y - ( (Float)(35) )));
HXLINE(  92)		bool _hx_tmp;
HXDLIN(  92)		if ((this->charaCol->y <= 359)) {
HXLINE(  92)			_hx_tmp = (this->asriel->y == 212);
            		}
            		else {
HXLINE(  92)			_hx_tmp = false;
            		}
HXDLIN(  92)		if (_hx_tmp) {
HXLINE(  93)			this->asriel->animation->play(HX_("Up",7b,4a,00,00),null(),null(),null());
HXLINE(  94)			::flixel::tweens::FlxTween_obj::tween(this->asriel, ::Dynamic(::hx::Anon_obj::Create(2)
            				->setFixed(0,HX_("x",78,00,00,00),380)
            				->setFixed(1,HX_("y",79,00,00,00),165)),((Float)0.6), ::Dynamic(::hx::Anon_obj::Create(1)
            				->setFixed(0,HX_("onComplete",f8,d4,7e,5d),this->asMove1_dyn())));
            		}
HXLINE(  97)		this->super::update(elapsed);
HXLINE(  99)		 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(  99)		if (_this->keyManager->checkStatusUnsafe(90,_this->status)) {
HXLINE( 100)			::haxe::Log_obj::trace((HX_("X = ",0b,44,43,3a) + this->charaCol->x), ::Dynamic(::hx::Anon_obj::Create(5)
            				->setFixed(0,HX_("className",a3,92,3d,dc),HX_("mapStates.theRuins.Zone3",43,b5,6b,62))
            				->setFixed(1,HX_("customParams",d7,51,18,ed),::cpp::VirtualArray_obj::__new(1)->init(0,(HX_("Y = ",aa,7a,ec,3a) + this->charaCol->y)))
            				->setFixed(2,HX_("methodName",cc,19,0f,12),HX_("update",09,86,05,87))
            				->setFixed(3,HX_("fileName",e7,5a,43,62),HX_("source/mapStates/theRuins/Zone3.hx",c7,56,e0,e0))
            				->setFixed(4,HX_("lineNumber",dd,81,22,76),100)));
            		}
            	}


void Zone3_obj::asMove1( ::flixel::tweens::FlxTween t){
            	HX_STACKFRAME(&_hx_pos_f48efaaa003b7ac9_105_asMove1)
HXDLIN( 105)		::flixel::tweens::FlxTween_obj::tween(this->asriel, ::Dynamic(::hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("x",78,00,00,00),510)
            			->setFixed(1,HX_("y",79,00,00,00),15)),((Float)1.15), ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("onComplete",f8,d4,7e,5d),this->asMove2_dyn())));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Zone3_obj,asMove1,(void))

void Zone3_obj::asMove2( ::flixel::tweens::FlxTween t){
            	HX_STACKFRAME(&_hx_pos_f48efaaa003b7ac9_110_asMove2)
HXDLIN( 110)		::flixel::tweens::FlxTween_obj::tween(this->asriel, ::Dynamic(::hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("x",78,00,00,00),465)
            			->setFixed(1,HX_("y",79,00,00,00),-55)),((Float)0.45), ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("onComplete",f8,d4,7e,5d),this->asMove3_dyn())));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Zone3_obj,asMove2,(void))

void Zone3_obj::asMove3( ::flixel::tweens::FlxTween t){
            	HX_STACKFRAME(&_hx_pos_f48efaaa003b7ac9_113_asMove3)
HXLINE( 114)		this->asriel->animation->play(HX_("Left",27,34,89,32),null(),null(),null());
HXLINE( 115)		::flixel::tweens::FlxTween_obj::tween(this->asriel, ::Dynamic(::hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("x",78,00,00,00),306)
            			->setFixed(1,HX_("y",79,00,00,00),-55)),((Float)0.8), ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("onComplete",f8,d4,7e,5d),this->asMove3_dyn())));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Zone3_obj,asMove3,(void))

void Zone3_obj::asMove4( ::flixel::tweens::FlxTween t){
            	HX_STACKFRAME(&_hx_pos_f48efaaa003b7ac9_118_asMove4)
HXLINE( 119)		this->asriel->animation->play(HX_("Left",27,34,89,32),null(),null(),null());
HXLINE( 120)		::flixel::tweens::FlxTween_obj::tween(this->asriel, ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("alpha",5e,a7,96,21),0)),((Float)0.6),null());
HXLINE( 121)		::flixel::tweens::FlxTween_obj::tween(this->asriel, ::Dynamic(::hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("x",78,00,00,00),306)
            			->setFixed(1,HX_("y",79,00,00,00),-80)),((Float)0.8), ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("onComplete",f8,d4,7e,5d),this->asMove3_dyn())));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Zone3_obj,asMove4,(void))


::hx::ObjectPtr< Zone3_obj > Zone3_obj::__new() {
	::hx::ObjectPtr< Zone3_obj > __this = new Zone3_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< Zone3_obj > Zone3_obj::__alloc(::hx::Ctx *_hx_ctx) {
	Zone3_obj *__this = (Zone3_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Zone3_obj), true, "mapStates.theRuins.Zone3"));
	*(void **)__this = Zone3_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Zone3_obj::Zone3_obj()
{
}

void Zone3_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Zone3);
	HX_MARK_MEMBER_NAME(zone,"zone");
	HX_MARK_MEMBER_NAME(check,"check");
	HX_MARK_MEMBER_NAME(chara,"chara");
	HX_MARK_MEMBER_NAME(charaCol,"charaCol");
	HX_MARK_MEMBER_NAME(canMove,"canMove");
	HX_MARK_MEMBER_NAME(asriel,"asriel");
	 ::flixel::FlxState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Zone3_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(zone,"zone");
	HX_VISIT_MEMBER_NAME(check,"check");
	HX_VISIT_MEMBER_NAME(chara,"chara");
	HX_VISIT_MEMBER_NAME(charaCol,"charaCol");
	HX_VISIT_MEMBER_NAME(canMove,"canMove");
	HX_VISIT_MEMBER_NAME(asriel,"asriel");
	 ::flixel::FlxState_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val Zone3_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"zone") ) { return ::hx::Val( zone ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"check") ) { return ::hx::Val( check ); }
		if (HX_FIELD_EQ(inName,"chara") ) { return ::hx::Val( chara ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"asriel") ) { return ::hx::Val( asriel ); }
		if (HX_FIELD_EQ(inName,"create") ) { return ::hx::Val( create_dyn() ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"canMove") ) { return ::hx::Val( canMove ); }
		if (HX_FIELD_EQ(inName,"asMove1") ) { return ::hx::Val( asMove1_dyn() ); }
		if (HX_FIELD_EQ(inName,"asMove2") ) { return ::hx::Val( asMove2_dyn() ); }
		if (HX_FIELD_EQ(inName,"asMove3") ) { return ::hx::Val( asMove3_dyn() ); }
		if (HX_FIELD_EQ(inName,"asMove4") ) { return ::hx::Val( asMove4_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"charaCol") ) { return ::hx::Val( charaCol ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Zone3_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"zone") ) { zone=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"check") ) { check=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"chara") ) { chara=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"asriel") ) { asriel=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"canMove") ) { canMove=inValue.Cast< bool >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"charaCol") ) { charaCol=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Zone3_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("zone",2c,a2,f8,50));
	outFields->push(HX_("check",c8,98,b6,45));
	outFields->push(HX_("chara",cb,9c,b3,45));
	outFields->push(HX_("charaCol",35,6c,d7,af));
	outFields->push(HX_("canMove",41,cb,b8,66));
	outFields->push(HX_("asriel",d0,0d,5d,4b));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Zone3_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(Zone3_obj,zone),HX_("zone",2c,a2,f8,50)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(Zone3_obj,check),HX_("check",c8,98,b6,45)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(Zone3_obj,chara),HX_("chara",cb,9c,b3,45)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(Zone3_obj,charaCol),HX_("charaCol",35,6c,d7,af)},
	{::hx::fsBool,(int)offsetof(Zone3_obj,canMove),HX_("canMove",41,cb,b8,66)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(Zone3_obj,asriel),HX_("asriel",d0,0d,5d,4b)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Zone3_obj_sStaticStorageInfo = 0;
#endif

static ::String Zone3_obj_sMemberFields[] = {
	HX_("zone",2c,a2,f8,50),
	HX_("check",c8,98,b6,45),
	HX_("chara",cb,9c,b3,45),
	HX_("charaCol",35,6c,d7,af),
	HX_("canMove",41,cb,b8,66),
	HX_("asriel",d0,0d,5d,4b),
	HX_("create",fc,66,0f,7c),
	HX_("update",09,86,05,87),
	HX_("asMove1",ae,b9,3f,5c),
	HX_("asMove2",af,b9,3f,5c),
	HX_("asMove3",b0,b9,3f,5c),
	HX_("asMove4",b1,b9,3f,5c),
	::String(null()) };

::hx::Class Zone3_obj::__mClass;

void Zone3_obj::__register()
{
	Zone3_obj _hx_dummy;
	Zone3_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("mapStates.theRuins.Zone3",43,b5,6b,62);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Zone3_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Zone3_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Zone3_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Zone3_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace mapStates
} // end namespace theRuins
